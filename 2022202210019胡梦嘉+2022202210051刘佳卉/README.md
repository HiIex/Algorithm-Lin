## 三维装箱问题

### 1.问题描述

物流公司在流通过程中，需要将打包完毕的箱子装入到一个货车的车厢中，为了提高物流效率，需要将车厢尽量填满，显然，车厢如果能被100%填满是最优的，但通常认为，车厢能够填满85%，可认为装箱是比较优化的。

设车厢为长方形，其长宽高分别为L，W，H；共有n个箱子，箱子也为长方形，第i个箱子的长宽高为li，wi，hi（n个箱子的体积总和是要远远大于车厢的体积），做以下假设和要求：

1. 长方形的车厢共有8个角，并设靠近驾驶室并位于下端的一个角的坐标为（0,0,0），车厢共6个面，其中长的4个面，以及靠近驾驶室的面是封闭的，只有一个面是开着的，用于工人搬运箱子；

2. 需要计算出每个箱子在车厢中的坐标，即每个箱子摆放后，其和车厢坐标为（0,0,0）的角相对应的角在车厢中的坐标，并计算车厢的填充率。

离线装箱要求如下：

1. 所有的参数为整数；2. 静态装箱，即从n个箱子中选取m个箱子，并实现m个箱子在车厢中的摆放（无需考虑装箱的顺序，即不需要考虑箱子从内向外，从下向上这种在车厢中的装箱顺序）；3. 所有的箱子全部平放，即箱子的最大面朝下摆放；4. 算法时间不做严格要求，只要1天内得出结果都可。

### 2.算法设计

与传统的以货物箱为基本单位进行装载的启发式算法不同，本实验基于块装载算法建立货物装载和放置的映射关系。

#### 2.1 块装载算法

在块装载过程中涉及到的基本概念如下：

- 简单块：由相同类型的货物沿同一方向堆叠而成的长方体，即构成该块的货物的长宽高均相等，且货物与货物之间没有任何空隙。生成的简单块体积小于车厢体积，且用于生成简单块的货物数量不超过所剩该类箱子的数量。
- 可装载空间：指车厢内可用于装载货物的空间，即车厢内未被填充货物的长方体空间。当车厢放入一个货物时，货物的前方、上方和右方分别 产生一个可装载空间，如下图所示：

![](https://raw.githubusercontent.com/LLLiu-1220/cloudimg/main/images/%E5%8F%AF%E8%A3%85%E8%BD%BD%E7%A9%BA%E9%97%B4.png)

装载策略：

对于给定的按照体积降序排序的`Block`序列，在考虑当前可装载空间列表时，根据可装载空间大小将`Block`序列依次进行试装，判断该`Block`能否放入可装载空间之一，返回所有能放入可装载空间并且有足够剩余货物能构成的块作为可装载块。

算法维护一个可装载空间堆栈，对于每个可装载空间进行装载时，若有可装载块，则由`findNextBlock`找到下一个最优的可装载块放入，并生成新的可装载空间。若无可装载块，尝试将当前可装载空间弹出堆栈，并将该可装载空间中的可利用空间与新的栈顶其他可装载空间合并。重复装载过程直至可装载空间堆栈为空，则代表装载完成。

#### 2.2 搜索算法

寻找下一个最优可装载块：本实验结合贪心算法和启发式搜索算法实现最优块的搜索，逐层搜索最多`MaxHeap`个节点。每一层取堆顶元素作为当前状态`curState`，找到一个可以产生后代节点即对应可装载块列表不为空的的可装载空间。遍历该后代节点所有的可装载块，在当前状态`curState`中放入下一个可装载块，形成下一个状态`nxtState`，针对`nxtState`进行不同深度的`DFS`搜索并且保存搜索后的最优值。最后更新当前状态和最优体积进入下一层搜索，并且由于生成`state`的途中可能有`state`装载完成，故当前状态和最优值都保存为全局的最佳体积和最佳已装载块列表。算法流程图如下：

![](https://raw.githubusercontent.com/LLLiu-1220/cloudimg/main/images/findnext.png)

DFS搜索：在寻找最优可装载块中调用的DFS搜索算法与普通的深度优先搜索不同之处在于，本算法中使用的`DFS`搜索算法形参中输入`depth`和`branch`，限制每次深度搜索的深度和搜索块的范围。这是因为搜索范围过大，会导致时间复杂度过高，影响算法效率。整体的`DFS`搜索深度由`depth`限制，当`depth`为0时即结束搜索；在搜索可装载块列表选择当前可装载空间的最优放置时，遍历搜索范围由`min(branch,(int)blockList->size())`确定，即将最大的可装载块遍历范围限制在`branch`，以降低复杂度。算法的流程图如下：

![](https://raw.githubusercontent.com/LLLiu-1220/cloudimg/main/images/dfs.png)

#### 2.3 块操作

- 放置块：将可装载块放置到可装载空间的操作。通过可装载空间堆栈获取当前可装载空间，将形参中的可装载块`block`放入该可装载空间。将对应的可装载空间从堆栈弹出，并且将当前可装载块从装载状态`state`的可装载块列表中删除，加入到`state`中的已装载列表。最后，根据当前空间状态，对栈顶可装载空间进行再次生成。
- 移除块:恢复放置块的操作。首先弹出放置操作生成的新的三个可装载空间，将块从装载状态`state`的已装载列表弹出，并重新将`block`加入到剩余可装载列表。最后恢复原来的可装载空间，将其加入`state`的可装载空间堆栈。

### 3.运行方法

```c++
如测试E1数据集：
    my3dbpp.exe data/E1.txt
运行时若想展示放置坐标，将以下代码的注释符号删除:
    //data[i].output_strategy(bls.sol_box,bls.sol_boxPos);
```

### 4.实验结果

| 组别       | E1-1   | E1-2   | E1-3   | E1-4   | E1-5   |
| ---------- | ------ | ------ | ------ | ------ | ------ |
| 空间利用率 | 85.16% | 82.58% | 82.58% | 85.06% | 84.22% |

| 组别       | E2-1   | E2-2   | E2-3   | E2-4   | E2-5   |
| ---------- | ------ | ------ | ------ | ------ | ------ |
| 空间利用率 | 86.32% | 85.00% | 84.85% | 82.75% | 82.87% |

| 组别       | E3-1   | E3-2   | E3-3   | E3-4   | E3-5   |
| ---------- | ------ | ------ | ------ | ------ | ------ |
| 空间利用率 | 84.31% | 83.93% | 84.14% | 85.17% | 84.90% |

| 组别       | E4-1   | E4-2   | E4-3   | E4-4   | E4-5   |
| ---------- | ------ | ------ | ------ | ------ | ------ |
| 空间利用率 | 83.95% | 83.59% | 82.76% | 84.93% | 83.87% |

| 组别       | E5-1   | E5-2   | E5-3   | E5-4   | E5-5   |
| ---------- | ------ | ------ | ------ | ------ | ------ |
| 空间利用率 | 84.49% | 84.61% | 84.41% | 83.62% | 85.84% |

实验结果图见`results`目录

